#!/bin/bash

set -e

SHOW_CLOSED_TASKS=0
TASKS=$(task +BLOCKED or +BLOCKING export | sed -e 's/,$//g' | jq -s -c '.')

function print_task_json() {
  local TASK_JSON=$1
  local INDENT=$2
  echo "$TASK_JSON" | jq -r -c "\"\
$(for ((I=0;I<$INDENT;I++));do echo -n " "; done)\
\(if (.id==0) then (.uuid) else .id end)\
\(if (.tags != null) then \" \(.tags)\" else \"\" end)\
 '\(.description)'\
\"" \
  | sed -e "s/^\(.\{$(tput cols)\}\).*$/\1/g"

#    STATUS=$(echo "$JSON" | jq -r '.status')
#    if [ "$STATUS" = "completed" ];then
#      tput setaf 1
#    elif [ "$STATUS" = "deleted" ];then
#      :
#    elif [ -n "$ISSUE" ];then
#      tput setaf 3
#    fi


#\(if (.issue != null) then \" (\(.issue))\" else \"\" end)\
# [\(.best//\"\"),\(.likely//\"\"),\(.worst//\"\")\
#\(if (.timelog != null) then \"=\([.timelog|fromjson|.[]|.spent]|add)\" else \"\" end)\
#]\
#\(if (.deliverable!=null) then \"\n$(for ((I=0;I<$INDENT;I++));do echo -n " "; done)   deliver: \(.deliverable)\" else \"\" end)\
#\(if (.casebest!=null) then \"\n$(for ((I=0;I<$INDENT;I++));do echo -n " "; done)   bestcase: \(.casebest)\" else \"\" end)\
#\(if (.caseworst!=null) then \"\n$(for ((I=0;I<$INDENT;I++));do echo -n " "; done)   worstcase: \(.caseworst)\" else \"\" end)\
#
#      ANNOTATIONS=$( echo "$JSON" | jq "if (.annotations!=null) then .annotations else [] end" )
#      if [ "$ANNOTATIONS" != "[]" ];then
#        echo "$ANNOTATIONS" | jq "\
#.[] |\
#\"$(for ((I=0;I<$INDENT;I++));do echo -n " "; done)     - \(.description)\"\
#" \
#        | sed -e 's/^"//g' -e 's/"$//g' \
#        | sed -e "s/^\(.\{$(( $(tput cols) - INDENT ))\}\).*$/\1/g"
#      fi

}

function show_depends() {
  local UUID=$1
  local INDENT=$2
  local TASK_JSON=$(echo "$TASKS" | jq -c ".[] | select(.uuid==\"$UUID\")")
  if [ -n "$TASK_JSON" ]; then
    print_task_json "$TASK_JSON" $INDENT
    for CHILD_UUID in $( echo "$TASK_JSON" | jq -r '.depends//""' |tr ',' '\n')
    do
      show_depends $CHILD_UUID $(( INDENT + 3))
    done
  else
    if [ "$SHOW_CLOSED_TASKS" = "1" ]; then
      local TASK_JSON=$(task $UUID export)
      print_task_json "$TASK_JSON" $INDENT
      for CHILD_UUID in $( echo "$TASK_JSON" | jq -r '.depends//""' |tr ',' '\n')
      do
        show_depends $CHILD_UUID $(( INDENT + 3))
      done
    fi
  fi
}

IDS=()
OPERATION="PRINT"

while true;do
  if [ "$#" -ge 1 ]; then

    if [[ "$1" =~ ^[0-9]*$ ]]; then 
      IDS+=($1)
      shift

    elif [ "$1" = "add" ]; then
      shift
      OPERATION="ADD"

    elif [ "$1" = "move" ]; then
      shift
      OPERATION="MOVE"

    elif [ "$1" = "all" ]; then
      shift
      SHOW_CLOSED_TASKS=1

    else 
      break
    fi
  else 
    break
  fi
done

if [ "$OPERATION" = "ADD" ];then
  echo "add operation"
  if [ ${#IDS[@]} -ge 1 ];then
    BLOCKED_TASK_ID=${IDS[0]}
    : ${MODS:=''}
    PROJECT=$(task $BLOCKED_TASK_ID export | jq -r '.project//""')
    NEW_TASK_ID=$(task add $@ proj:$PROJECT $MODS | sed 's/^.*task \([0-9]*\)\.$/\1/g')
    task $BLOCKED_TASK_ID mo depends:$NEW_TASK_ID
    echo "$NEW_TASK_ID"
  else
    echo "need one id to add a new child task"
  fi
  exit

elif [ "$OPERATION" = "MOVE" ];then
  echo "move operation"
  if [ ${#IDS[@]} -ge 2 ];then
    TASK_ID=${IDS[0]}
    NEW_PARENT_ID=${IDS[1]}
    if [ "$#" -ge 3 ];then
      OLD_PARENT_ID=$3
    else
      TASK_UUID=$(task $TASK_ID _uuid)
      OLD_PARENT_ID=$(task depends.has:$TASK_UUID id)
    fi
    if [ -n "$OLD_PARENT_ID" ];then
      task $OLD_PARENT_ID modify depends:-$TASK_ID
    fi
    task $NEW_PARENT_ID modify depends:$TASK_ID
  else
    echo "need two ids to move reparent a child task"
  fi
  exit

elif [ "$OPERATION" = "PRINT" ];then
  #UUIDS=$(task status:pending $@ _uuids)
  if [ ${#IDS[@]} -ge 1 ];then
    UUIDS=$(task ${IDS[@]} _uuids)
  elif [ ! -z "$@" ]; then
    UUIDS=$(task $@ _uuids)
  else 
    UUIDS=$(task +BLOCKED -BLOCKING _uuids)
  fi
  if [ -n "$UUIDS" ]; then
    for UUID in $UUIDS;do
      show_depends $UUID 0
    done
  else
    echo "no task found for the filters: $@"
  fi

fi

