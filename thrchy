#!/bin/bash

set -e

SHOW_ALL_TASKS=0
TASKS=$(task +BLOCKED or +BLOCKING export | jq -s -c '.')

function print_task_json() {
  local TASK_JSON=$1
  local INDENT=$2
  echo "$TASK_JSON" | jq -r -c "\"\
$(for ((I=0;I<$INDENT;I++));do echo -n " "; done)\
\(if (.id==0) then (.uuid|.[0:index(\"-\")]) else .id end)\
\(if (.tags != null) then \" \(.tags)\" else \"\" end)\
 '\(.description)'\
\"" \
  | sed -e "s/^\(.\{$(tput cols)\}\).*$/\1/g"

#    STATUS=$(echo "$JSON" | jq -r '.status')
#    if [ "$STATUS" = "completed" ];then
#      tput setaf 1
#    elif [ "$STATUS" = "deleted" ];then
#      :
#    elif [ -n "$ISSUE" ];then
#      tput setaf 3
#    fi


#\(if (.issue != null) then \" (\(.issue))\" else \"\" end)\
# [\(.best//\"\"),\(.likely//\"\"),\(.worst//\"\")\
#\(if (.timelog != null) then \"=\([.timelog|fromjson|.[]|.spent]|add)\" else \"\" end)\
#]\
#\(if (.deliverable!=null) then \"\n$(for ((I=0;I<$INDENT;I++));do echo -n " "; done)   deliver: \(.deliverable)\" else \"\" end)\
#\(if (.casebest!=null) then \"\n$(for ((I=0;I<$INDENT;I++));do echo -n " "; done)   bestcase: \(.casebest)\" else \"\" end)\
#\(if (.caseworst!=null) then \"\n$(for ((I=0;I<$INDENT;I++));do echo -n " "; done)   worstcase: \(.caseworst)\" else \"\" end)\
#
#      ANNOTATIONS=$( echo "$JSON" | jq "if (.annotations!=null) then .annotations else [] end" )
#      if [ "$ANNOTATIONS" != "[]" ];then
#        echo "$ANNOTATIONS" | jq "\
#.[] |\
#\"$(for ((I=0;I<$INDENT;I++));do echo -n " "; done)     - \(.description)\"\
#" \
#        | sed -e 's/^"//g' -e 's/"$//g' \
#        | sed -e "s/^\(.\{$(( $(tput cols) - INDENT ))\}\).*$/\1/g"
#      fi

}

function show_depends() {
  local UUID=$1
  local INDENT=$2
  local TASK_JSON=$(echo "$TASKS" | jq -c ".[] | select(.uuid==\"$UUID\")")
  if [ -n "$TASK_JSON" ]; then
    print_task_json "$TASK_JSON" $INDENT
    for CHILD_UUID in $( echo "$TASK_JSON" | jq -r '.depends//""' |tr ',' '\n')
    do
      show_depends $CHILD_UUID $(( INDENT + 3))
    done
  else
    if [ "$SHOW_ALL_TASKS" = "1" ]; then
      local TASK_JSON=$(task $UUID export)
      print_task_json "$TASK_JSON" $INDENT
      for CHILD_UUID in $( echo "$TASK_JSON" | jq -r '.depends//""' |tr ',' '\n')
      do
        show_depends $CHILD_UUID $(( INDENT + 3))
      done
    fi
  fi
}

if [ "$1" = "add" ] && [ "$#" -ge 3 ]; then
  shift
  BLOCKED_TASK_ID=$1
  shift
  : ${MODS:=''}
  PROJECT=$(task $BLOCKED_TASK_ID export | jq -r '.project//""')
  NEW_TASK_ID=$(task add $@ proj:$PROJECT $MODS \
  $(task $BLOCKED_TASK_ID export | jq -r -c '.tags | if (index("w")!=null) then "+w" else "" end') \
  | sed 's/^.*task \([0-9]*\)\.$/\1/g')
  task $BLOCKED_TASK_ID mo depends:$NEW_TASK_ID
  echo "$NEW_TASK_ID"
  exit

elif [ "$1" = "move" ] && [ "$#" -ge 3 ]; then
  shift
  TASK_ID=$1
  NEW_PARENT_ID=$2
  if [ "$#" -ge 3 ];then
    OLD_PARENT_ID=$3
  else
    TASK_UUID=$(task $TASK_ID _uuid)
    OLD_PARENT_ID=$(task depends.has:$TASK_UUID id)
  fi
  if [ -n "$OLD_PARENT_ID" ];then
    task $OLD_PARENT_ID modify depends:-$TASK_ID
  fi
  task $NEW_PARENT_ID modify depends:$TASK_ID
  exit
fi

if [ "$1" = "all" ]; then
  shift
  SHOW_ALL_TASKS=1
fi

#UUIDS=$(task status:pending $@ _uuids)
UUIDS=$(task $@ _uuids)
if [ -n "$UUIDS" ]; then
  for UUID in $UUIDS;do
    show_depends $UUID 0
  done
else
  echo "no task found for the filters: $@"
fi

